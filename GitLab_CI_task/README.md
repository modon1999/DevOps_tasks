Задача: создание отдельных атомарных операций CI/CD, вынесеные в версионируемые модули и 
использовать общий составной CI/CD workflow.
Чекпоинты:
  
  Light:
1. Написать Dockerfile для тестового проекта.
2. Написать GitLab-CI пайплайн со сборкой образа и публикацией его в GitLab Registry.
3. Создание в GitLab собственную группу DevOps, в которой создать сабгруппы gitlab-ci-includes 
и gitlab-ci-flows. Вынести сборку образа в отдельный репозиторий docker-build и 
проверсионировать. Подключить шаг сборки через include.
4. Добавить шаг с развертыванием и последующим обновлением приложения на сервере. Сервер можно
развернуть на любой удобной площадке, включая Vagrant.
5. Аналогично пункту 3 вынести шаг с деплоем в качестве подключаемого модуля.
  
  Normal:
1. Вынести .gitlab-ci.yml из проекта в отдельный репозиторий внутри группы flows, версионировать 
и подключить внутри репозитория с проектом, как удалённый CI.
2. Продумать параметризацию имеющегося инклуда билда - чтобы можно было получать разные названия
и тэги образов, а также пушить в разные реджистри используя один и тот же инклуд шага билда.
3. Продумать параметризацию имеющегося инклуда деплоя, чтобы можно было выполнять деплой на 
разные сервера(условно дев, тест, прод) используя один и тот же инклуд шага деплоя.
4. Внедрить в пайплайн шаг проверки линтеров, оформить его по подобию предыдущих шагов.
5. Создать репозиторий который будет собирать базовый образ, используемый внутри образа проекта,
реализовать пайплайн с этапами тестирования, сборки и публикации, оформив его как отдельный 
gitlab-ci-flow.

  
  Hard:
1. Добавить в пайплайн шаг с деплоем приложения в kubernetes через helm, используя инклуд
соответствующей джобы внутри ci-flow. 
2. Реализоватьпараметризацию шага развертывания в разные кубурнетес кластера: нужна возможность
переопределять KUBECONFIG и VALUES в зависимости от контура.
3. Применить к шагам деплоя и роллбэка механизм environments GitLab.
